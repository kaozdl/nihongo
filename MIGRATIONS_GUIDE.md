# Database Migrations Guide

This guide explains how to use Alembic for database migrations in the JLPT Test Manager.

## What are Migrations?

Database migrations are version control for your database schema. They allow you to:

- **Track changes** to your database structure over time
- **Apply changes** consistently across development, testing, and production
- **Rollback changes** if something goes wrong
- **Share schema changes** with team members
- **Maintain database history** for auditing

## Quick Start

### Initial Setup (Already Done)

The project is already configured with Alembic. The initial migration has been created.

### Applying Existing Migrations

When you clone this project or pull changes that include new migrations:

```bash
# Activate virtual environment
pyenv activate nihongo  # or: source venv/bin/activate

# Apply all pending migrations
flask db-upgrade

# Or use alembic directly
alembic upgrade head
```

## Common Commands

### Flask CLI Commands (Recommended)

```bash
# Apply all pending migrations
flask db-upgrade

# Create a new migration (after model changes)
flask db-migrate

# Rollback the last migration
flask db-downgrade

# View migration history
flask db-history
```

### Alembic Commands (Advanced)

```bash
# Create a new migration with custom message
alembic revision --autogenerate -m "Add user profile fields"

# Apply all migrations
alembic upgrade head

# Rollback one migration
alembic downgrade -1

# Rollback to specific revision
alembic downgrade <revision_id>

# View current database version
alembic current

# View migration history
alembic history

# Show difference between database and models
alembic check
```

## Creating Migrations

### Step 1: Modify Your Models

Make changes to your SQLAlchemy models in the `models/` directory.

**Example:** Adding a new field to User model

```python
# models/user.py
class User(UserMixin, db.Model):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    
    # NEW FIELD
    is_premium = db.Column(db.Boolean, default=False)
```

### Step 2: Generate Migration

```bash
# Using Flask CLI
flask db-migrate

# Or using Alembic directly with message
alembic revision --autogenerate -m "Add is_premium field to users"
```

This will create a new file in `alembic/versions/` with timestamp and description.

### Step 3: Review the Migration

**Always review auto-generated migrations!** Open the new file in `alembic/versions/`:

```python
"""Add is_premium field to users

Revision ID: abc123def456
Revises: 98233c85ce1c
Create Date: 2025-10-13 14:30:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'abc123def456'
down_revision = '98233c85ce1c'
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic ###
    op.add_column('users', sa.Column('is_premium', sa.Boolean(), nullable=True))
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic ###
    op.drop_column('users', 'is_premium')
    # ### end Alembic commands ###
```

### Step 4: Apply the Migration

```bash
# Apply migration to database
flask db-upgrade
```

### Step 5: Test Your Changes

```bash
# Run your application
flask run

# Run tests
pytest
```

## Migration Best Practices

### 1. **Always Review Auto-Generated Migrations**

Alembic's autogenerate is powerful but not perfect. It may miss:
- Table renames (appears as drop + create)
- Column renames (appears as drop + add)
- Complex constraint changes
- Data migrations

### 2. **Add Data Migrations When Needed**

For complex changes, add data migration logic:

```python
def upgrade():
    # Schema change
    op.add_column('users', sa.Column('full_name', sa.String(200), nullable=True))
    
    # Data migration
    from sqlalchemy import table, column
    users = table('users',
        column('id', sa.Integer),
        column('email', sa.String),
        column('full_name', sa.String)
    )
    
    # Update existing data
    op.execute(
        users.update().values(full_name='Unknown User')
    )
    
    # Make column non-nullable after data migration
    op.alter_column('users', 'full_name', nullable=False)
```

### 3. **Test Migrations Both Ways**

```bash
# Test upgrade
flask db-upgrade

# Test downgrade
flask db-downgrade

# Re-apply
flask db-upgrade
```

### 4. **Use Descriptive Messages**

```bash
alembic revision --autogenerate -m "Add user profile and preferences"
alembic revision --autogenerate -m "Create indexes for question search"
alembic revision --autogenerate -m "Add soft delete to exams"
```

### 5. **One Migration Per Feature**

Don't bundle unrelated changes. Create separate migrations for:
- Each new feature
- Each bug fix
- Each refactoring

### 6. **Never Edit Applied Migrations**

Once a migration is applied to production:
- ❌ Don't edit it
- ✅ Create a new migration to fix issues

### 7. **Keep Migrations Small**

Break large schema changes into smaller, manageable migrations.

## Common Scenarios

### Scenario 1: Adding a New Model

1. Create the model in `models/`
2. Import it in `alembic/env.py` (if not auto-imported)
3. Generate migration: `flask db-migrate`
4. Review the migration file
5. Apply: `flask db-upgrade`

### Scenario 2: Adding a Field

1. Add field to model
2. Generate migration: `flask db-migrate`
3. Review and optionally add default values
4. Apply: `flask db-upgrade`

### Scenario 3: Renaming a Column

Alembic can't auto-detect renames. Manual migration needed:

```python
def upgrade():
    # Don't use op.alter_column as it doesn't work well with SQLite
    # For SQLite, you need to recreate the table
    
    # For PostgreSQL/MySQL:
    # op.alter_column('users', 'old_name', new_column_name='new_name')
    
    # For SQLite (more complex):
    # 1. Create new column
    # 2. Copy data
    # 3. Drop old column
    pass

def downgrade():
    # Reverse the operation
    pass
```

### Scenario 4: Adding an Index

```python
def upgrade():
    op.create_index('ix_questions_created_at', 'questions', ['created_at'])

def downgrade():
    op.drop_index('ix_questions_created_at', 'questions')
```

### Scenario 5: Adding a Foreign Key

```python
def upgrade():
    op.create_foreign_key(
        'fk_test_answers_question_id',
        'test_answers', 'questions',
        ['question_id'], ['id']
    )

def downgrade():
    op.drop_constraint('fk_test_answers_question_id', 'test_answers')
```

## Troubleshooting

### Issue: "Can't locate revision identified by 'xyz'"

**Solution:** Database and migration files are out of sync.

```bash
# Check current database version
alembic current

# Check what migrations exist
alembic history

# Force stamp database to current state (DANGEROUS)
alembic stamp head
```

### Issue: "Target database is not up to date"

**Solution:** Apply pending migrations

```bash
flask db-upgrade
```

### Issue: Migration fails halfway

**Solution:** Fix the issue and retry

```bash
# Check current state
alembic current

# Fix the migration file or database issue

# Try again
flask db-upgrade
```

### Issue: Need to rollback after deployment

```bash
# Rollback one migration
flask db-downgrade

# Or multiple steps
alembic downgrade -2

# Or to specific version
alembic downgrade abc123def456
```

### Issue: Alembic detects changes that don't exist

**Solution:** This can happen due to:
- Different SQLAlchemy versions
- Platform differences (e.g., String lengths)

Add to `alembic/env.py`:

```python
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    compare_type=False,  # Don't compare column types
    compare_server_default=False  # Don't compare defaults
)
```

## Integration with Development Workflow

### Daily Development

```bash
# 1. Pull latest code
git pull

# 2. Apply any new migrations
flask db-upgrade

# 3. Make your changes to models

# 4. Create migration for your changes
flask db-migrate

# 5. Test your migration
flask run

# 6. Commit both model changes and migration
git add models/ alembic/versions/
git commit -m "Add user preferences feature"
```

### Before Committing

```bash
# Verify migration works in both directions
flask db-downgrade
flask db-upgrade

# Run tests
pytest
```

### Deployment

```bash
# On production server
git pull
flask db-upgrade
flask run  # or restart production server
```

## SQLite Limitations

SQLite has limitations with `ALTER TABLE`:
- Can't drop columns (in older versions)
- Can't rename columns easily
- Can't modify columns

**Workaround:** Create new table, copy data, drop old table, rename new table.

**Alembic handles this automatically** for most operations with `batch_alter_table`:

```python
with op.batch_alter_table('users') as batch_op:
    batch_op.add_column(sa.Column('new_field', sa.String(50)))
    batch_op.drop_column('old_field')
```

## Migration File Structure

```
alembic/
├── versions/
│   ├── 98233c85ce1c_initial_migration.py
│   └── abc123def456_add_user_preferences.py
├── env.py         # Migration environment configuration
├── script.py.mako # Template for new migrations
└── README         # Alembic's README
```

## Additional Resources

- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
- [Flask-Migrate](https://flask-migrate.readthedocs.io/) (Alternative to raw Alembic)

## Summary of Commands

| Task | Command |
|------|---------|
| Apply migrations | `flask db-upgrade` |
| Create new migration | `flask db-migrate` |
| Rollback last migration | `flask db-downgrade` |
| View migration history | `flask db-history` |
| Check current version | `alembic current` |
| Manual migration | `alembic revision -m "message"` |
| Upgrade with Alembic | `alembic upgrade head` |
| Downgrade with Alembic | `alembic downgrade -1` |

---

**Remember:** Always backup your database before applying migrations in production!

